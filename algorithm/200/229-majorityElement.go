//ç»™å®šä¸€ä¸ªå¤§å°ä¸º n çš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­æ‰€æœ‰å‡ºç°è¶…è¿‡ âŒŠ n/3 âŒ‹ æ¬¡çš„å…ƒç´ ã€‚
//
//
//
//
//
// ç¤ºä¾‹ 1ï¼š
//
//
//è¾“å…¥ï¼š[3,2,3]
//è¾“å‡ºï¼š[3]
//
// ç¤ºä¾‹ 2ï¼š
//
//
//è¾“å…¥ï¼šnums = [1]
//è¾“å‡ºï¼š[1]
//
//
// ç¤ºä¾‹ 3ï¼š
//
//
//è¾“å…¥ï¼š[1,1,1,3,3,2,2,2]
//è¾“å‡ºï¼š[1,2]
//
//
//
// æç¤ºï¼š
//
//
// 1 <= nums.length <= 5 * 10â´
// -10â¹ <= nums[i] <= 10â¹
//
//
//
//
// è¿›é˜¶ï¼šå°è¯•è®¾è®¡æ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€ç©ºé—´å¤æ‚åº¦ä¸º O(1)çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚
// Related Topics æ•°ç»„ å“ˆå¸Œè¡¨ è®¡æ•° æ’åº ğŸ‘ 465 ğŸ‘ 0

package algorithm_200

// æ‘©å°”æŠ•ç¥¨æ³•ï¼šæ‘©å°”æŠ•ç¥¨æ³•çš„æ ¸å¿ƒæ€æƒ³ä¸ºå¯¹æ‹¼æ¶ˆè€—ã€‚
// é¦–å…ˆæˆ‘ä»¬è€ƒè™‘æœ€åŸºæœ¬çš„æ‘©å°”æŠ•ç¥¨é—®é¢˜ï¼Œæ¯”å¦‚æ‰¾å‡ºä¸€ç»„æ•°å­—åºåˆ—ä¸­å‡ºç°æ¬¡æ•°å¤§äºæ€»æ•°1/2çš„æ•°å­—ï¼ˆå¹¶ä¸”å‡è®¾è¿™ä¸ªæ•°å­—ä¸€å®šå­˜åœ¨ï¼‰ã€‚
// æˆ‘ä»¬å¯ä»¥ç›´æ¥åˆ©ç”¨åè¯æ³•è¯æ˜è¿™æ ·çš„æ•°å­—åªå¯èƒ½æœ‰ä¸€ä¸ªã€‚
// é¢˜ç›®è¦æ±‚æ‰¾å‡ºæ¬¡æ•°å¤§äº n/3 çš„æ•°ï¼Œåˆ™æœ€å¤šæœ‰ 2 ä¸ª
func majorityElement(nums []int) (res []int) {
	var v1, v2, e1, e2 int
	for i := 0; i < len(nums); i++ {
		if v1 > 0 && e1 == nums[i] {
			v1++
		} else if v2 > 0 && e2 == nums[i] {
			v2++
		} else if v1 == 0 {
			e1 = nums[i]
			v1++
		} else if v2 == 0 {
			e2 = nums[i]
			v2++
		} else {
			v1--
			v2--
		}
	}

	var n1, n2 int
	for i := 0; i < len(nums); i++ {
		if v1 > 0 && nums[i] == e1 {
			n1++
		}
		if v2 > 0 && nums[i] == e2 {
			n2++
		}
	}
	if v1 > 0 && n1 > len(nums)/3 {
		res = append(res, e1)
	}
	if v2 > 0 && n2 > len(nums)/3 {
		res = append(res, e2)
	}
	return
}

func majorityElement0(nums []int) (res []int) {
	aMap := make(map[int]int)
	for i := 0; i < len(nums); i++ {
		if _, ok := aMap[nums[i]]; !ok {
			aMap[nums[i]] = 0
		}
		aMap[nums[i]]++
	}
	for k, v := range aMap {
		if v > len(nums)/3 {
			res = append(res, k)
		}
	}
	return
}
